## 1. 命名空间

**作用**：每一个命名空间是一个作用域，避免名字冲突。

**定义**：<kbd>namespace 名字 {}</kbd>

**成员包括**:类、变量(及其初始化操作)、函数(及其定义)、模板、其他命名空间

**使用**：

```c++
using namespace std;//全部导入
using std::cout;//导入一个
```

**命名空间别名**：此时a就是别名

```c++
namespace aaaaaaaaaaaaaaaaaaa{}

namespace a = aaaaaaaaaaaaaaaaaaa;
```



> **特别地**：
>
> + 每个命名空间是一个作用域，再同一个命名空间中，只能存在唯一实体;
> + 命名空间是不连续的：故可以将类定义、函数声明写在头文件中，而函数是实现写在源文件中。
>
> ```c++
> //User.h
> 
> #ifndef USER
> #define USER
> 
> #include <iostream>
> namespace school {
> 
> 	class student {
> 
> 	public:
> 		int id;
> 		std::string name;
> 
> 
> 	};
> }
> 
> #endif 
> 
> 
> ```

**其他命名空间**：

+ 全局命名空间:全局变量、函数等实际默认添加到全局命名空间中，用::直接访问;
+ 内联命名空间<kbd>inline namespace 名字 {}</kbd>: 外部的命名空间可以直接访问不用添加 name::访问；
+ 嵌套命名空间：嵌套未命名命名空间、内联命名空间可以直接用外层命名空间访问；
+ 未命名命名空间 ：静态的声明周期,在给定的文件内不连续，可以直接使用，但会和全局实体产生冲突。

## 2.const限定符

**初始化**:常量初始化、字面值、表达式，编译时会将用到常量的地方替换为它的字面值。

```c++

int a =1;
const int b = a;//表达式初始化
const int c = a*2;//表达式初始化
const int d = fun();
```

**特别地**：const修饰的常量只能在文件内有效，不同文件定义了相同的const常量则视为独立的常量，如果多个文件要共享同一个常量，则不管定义和声明，都添加extern。

```c++
//a.cpp
extern int a =1;

//b.cpp
extern int a;
```





## 3. 指针

**定义**:指针也是对象，保存的是其他对象的地址。指针不能指向引用，引用不是对象。存在对指针的引用。

```c++
int *p;
int *m,*n;

int *& y = p; //对指针的引用
```



**空指针**:

```c++

int *p1 = 0;
int *p2 = nullptr; //c++11
int *p3 = NULL;//#include <cstdlib.h>
```

**void*指针**:存放任意类型的指针

```c++
void *p = &obj;
```

**野指针**:造成访问无权限的内存地址

```c++
int *p = (int*)0x1100;//错误
```



**顶层const，常量指针**:指针自己本身是常量

```c++
int *const a = &n;
```

**底层const，指向常量的指针**:不能通过指针改变指向对象的值，但指针本身能变

```c++
const int a = &n;
```

***

```c++
const int *const a = &n;
```



## 4.左值引用

**定义**：引用是某个对象的别名，它不是对象。

```c++

int a =1;
int &b = a;//引用必须初始化，且右值必须为对象
```

**const引用**:普通引用可以修改原对象值，const引用不能修改原对象的值,const引用可以引用常量和变量

```c++
const int a = 1;
int &b = a;//错误
const int &b = a;//正确

int m = 1;
const int &n = m; //正确
```

## 5.函数

+ **函数声明**:可以省略参数名

```c++
//以下都等价
int fun(int,bool);
int fun(int a,bool b);
```

+ **函数参数不能为数组，传入数组自动转化为指针**：

```c++
//以下都等价
int fun(int* p);
int fun(int*);
int fun(int[]);
int fun (int [10]);
```

+ **函数什么时候产生临时量**(临时变量是const的)
  
  + 类型转换(隐式转换、强制转换，并且指正常情况下的类型转换或函数形参、实参的类型转换)
  + 形参为const左值引用、实参类型为常量(左值引用不能引用右值，这里临时变量就是充当左值)
  + 返回值为非引用
  
+ **返回值不要返回局部变量的引用、指针**

+ **自动返回类型**：有些返回类型不直观，不好描述

  + C++11尾置返回类型

  ```c++
  auto fun() -> int (*)[10];//返回数组指针，该指针指向含有10元素的数组
  ```

  + decltype:通过变量确定返回类型

  ```c++
  int a = i;
  decltype(a) fun();
  ```

  

+ **默认参数**

  + 如果一个形参提供了默认参数，那它的右边所有参数都要提供默认参数

  ```c++
  int fun(int a,int b = 1,int c = 2);
  
  int m = fun(1);
  ```

  + 如果为形参提供新的数据，那么都是从左往右补充的

  ```c++
  void fun(int a = 1; int b = 2);
  fun(2);//等价于 fun(2,2);
  ```

  + 如果在第一次声明时提供了默认参数，那往后声明不能再改变，但可以为没有默认参数的提供默认参数

  ```c++
  void fun(int a,int b =2);//第一次声明
  void fun(int a =2,int b);//第二次声明
  ```

+ **函数重载**:名称相同，形参列表不同
  
  + 顶层const和未定义const会产生二义性
  + 函数重载编译器选择函数有三种情况：最佳匹配、没找到、最佳匹配有两个
  
+ **inline函数**

  + inline函数可以多次定义，所以一般定义在头文件中
  + inline函数可以减小一般函数调用的开销

  

+ **函数指针**

```c++

//定义函数a
int a(int b) {

    return 0;
}

//定义参数类型为函数指针的函数test
int test(int (*p)(int)) {

    p(1);
    (*p)(2);

    return 0;

}


//调用
test(a); //函数名就是函数本身的函数指针
test(*b);

//简化类型

//p为int(*p)(int)函数指针类型的简称
typedef int (*p)(int); 

```





## 6.类

### 1.构造函数

类通过一个或多个特殊的成员函数控制其对象的初始化过程，这些函数称为**构造函数**。

+ **默认构造函数**

  不带任何参数的构造函数，如果不提供任何的构造函数，编译器会默认提供。只要定义了一个构造函数则不会再提供默认构造函数

  + 默认构造函数体内部会提供成员的默认初始化

  + 提供默认参数的构造函数也可以认为是默认构造函数

    ```c++
    class A{
        
        A(int a = 1);
    }
    ```

    

+ **保存默认构造函数**

  如果自定义了构造函数那编译器不再提供默认的构造函数，但是又想保存原来的构造函数，可以使用defalut

  ```c++
  Test() = default;//C++11新标准中，要求编译器生成默认构造函数， = default可以在类内部(内联)，也可以在外部(外部)
  ```

  自定义无参构造函数且什么都不做
  
  ```c++
  
  
  class A{
      
      private:
      	int a;
      public:
      	A(){
              
          }
      
  };
  
  A test = A(); //对象test的成员a初始值就是任意，没有被初始化
  ```
  
+ **提供默认参数的构造函数也可以作为默认构造函数**

  ```c++
  class A{
      
      string name;
      public A(string v = "") : name(v){
          
      }
      
  }
  ```





+ **委托构造函数**

  调用无参构造函数，则最终调用的是三个参数的构造函数，首先最终使用三个参数构造函数的初始化列表初始化完成员变量，接着依次执行三参函数体、两参函数体、无参函数体

  ```c++
  
  
  son s;
  
  
  class son
  {
  	int a;
  	int b;
  	int c;
  
  	
  public:
  
  	//顺序1
      son(int v1, int v2,int v3) :a(v1), b(v2),c(v3) {
  		
  	}
      //顺序2
  	son(int v1, int v2) :son(v1,v2,99){
  		
  	}
  
  	
  	//顺序3
  	son() : son(0, 0) {
  		
  
  	}
  
  };
  
  
  =================
      
  
  ```

+ **转换构造函数**

  当构造函数只有一个参数、类型为基本类型或其他类型则可作为转换构造函数（隐式转换）。这里类型要保持相同，只会进行一次类型转换

  避免隐式转换：转换构造函数用explicit修饰

  ```c++
  
  class A {
      
      
      A(int a){
          
      }
      
      
  };
  
  A a = 5; // A a = A(a);
  A b = 1.1;//编译错误，因为只会进行一一次隐式转换
  ```

  

### 2.成员初始化

按执行顺序排（注意：列表初始化不会存在‘=’问题)

+ 声明时初始化

  发生在构造函数之前

  ```c++
  class A{
      
      int a = 1; //对于内置类型分配内存空间后直接赋予初始值,对于自定义类型'='会造成值拷贝，可以不用‘=’
      
  };
  ```

  

+ 列表初始化

  发生在构造函数体之前，且是分配内存空间后直接赋值,**列表初始化的顺序是随机的**

  ```C++
  class A{
      
     int a;
     int b;
      A(int vl,int v2):a(v1),b(v2){
          
          
      }
  };
  
  ```

  

+ 构造函数初始化

  ```c++
  class A{
      
      A(){
          a = b = 0;
      }
      
  };
  ```



### 3. struct  、 class定义类

+ struct :在第一个访问说明符之前成员都是public的

  ```c++
  struct A{
      
      int a; //public
      int b; //public
      private:
      	int c;
      
  };
  
  ```

+ class:在第一个访问说明之前成员都是private的

  ```c++
  class A{
      
      int a;//private
      int b;//private
      private:
      	int c;
  }
  ```

### 4. 友元

某个函数或者类可能会访问某个类的私有成员，则把它们声明成该类的友元就行

通过friend关键字声明成友元，声明位置随意不受访问限定符限制。**声明友元只是说明能访问私有成员，在实际使用友元函数时还是需要再进行函数声明，友元声明!=函数声明**

```c++

//类A
class A {
    friend void testFun(A a);
    
    friend void testFunB(A a) {
        
        //友元可以直接定义在类中，但它不属于成员函数，使用之前也必须先声明
    }
    friend class B;
    int a;
    int b;
};

//函数testFun()
void testFun(A a){
    
    a.b;
    
}

//类B
class B{
    //内部都可以访问class A的私有成员
}
```

### 5. 让成员函数成为内联函数

+ 定义在类内部的成员函数默认是inline的

+ 声明时设为inline，外部定义也用inline，并且和类定义在同一个头文件中

  ```c++
  User.h
      
  class A {
      
      inline void method();
  };
  
  inline void A::method(){
      
  }
  ```



### 6.类的向前声明

先声明但不定义

```c++
class A;
```

类本身不能作为成员变量，但可以作为引用或指针类型

```c++
class A{
    A& a;
    A* b;
}
```

### 7.聚合类

+ 成员都是public
+ 没有定义构造函数
+ 没有类初始值
+ 没有基类、virtual函数

```c++
struct A{
    int a;
    bool b;
    float c;
}


```

### 8.静态成员

static修饰的静态变量、函数，static只在声明时用



